---
title: "1. Carregando e limpando as bases de dados"
output: html_document
---

**Atenção**: Não esqueça de rodar antes o arquivo "0"

# 1. Carregando e limpando as bases de dados

## 1.1 Importando pacotes

Antes de começar, estes são os pacotes que serão necessários para manipulação destes dados. Caso ainda não os tenha instalados, é só retirar o "\#" da frente e rodar as células

```{r}
#install.packages("dplyr")
#install.packages("readr")
#install.packages("here")
#install.packages("lubridate")
#install.packages("stringi")
#install.packages("data.table")
#install.packages("purrr")
#install.packages("tidyr")
#install.packages("readxl")
#install.packages("httr")
#install.packages("jsonlite")
#install.packages("stringr")
#install.packages("purrr")
#install.packages("readxl")
#install.packages("ggplot2")
```

```{r, 'packages', warning=FALSE}
library(readr)
library(here)
library(dplyr)
library(lubridate)
library(data.table)
```

## 1.2 Base de Dados sobre Desastres

Os dados sobre a ocorrência de desastres foram levantados a partir do "Atlas Digital de Desastres no Brasil", publicado pelo Ministério de Integração e Desenvolvimento Regional do Brasil.

Eles podem ser baixados aqui: <http://atlasdigital.mdr.gov.br/paginas/downloads.xhtml>

A versão que utilizo é a publicada em 14 de abril de 2025, que inclui dados de 1991 a 2024

```{r, 'Baixando_desastres', warning=FALSE}
# Coloque a base de dados extraída do site do Atlas Digital de Desastres na pasta "Dados"


Desastres <- read_csv2(file = here("Dados/BD_Atlas_1991_2024_v1.0_2025.04.14_Consolidado.csv"), locale = locale(encoding = "Latin1")) #Baixa a base de dados de Desastres
```

```{r, 'Limpando_desastres'}

Desastres <- Desastres  %>% 
  select(Cod_IBGE_Mun,Nome_Municipio,Sigla_UF,regiao,Data_Evento,tipologia, descricao_tipologia, grupo_de_desastre, Status, DH_Descricao, DH_MORTOS, DH_DESAPARECIDOS, DH_total_danos_humanos_diretos, DM_Descricao, DM_total_danos_materiais) %>% #Seleciona as colunas de interesse
  rename("UF" = "Sigla_UF",
         "Desastre" = "descricao_tipologia",
         "Grupo_Desastre" = "grupo_de_desastre") %>% #Simplifica o nome de algumas colunas
     filter(!(Desastre %in% c('Doenças infecciosas','Rompimento/Colapso de barragens', 'Outros'))) %>%  #Remove as emergências que não são causadas diretamente por fatores climáticos
  mutate(Data = as.Date(Data_Evento, format = "%d/%m/%Y"),
                        "Mês" = month(`Data`), 
                        "Ano" = year(`Data`), #Atualiza colunas de tempo
           Municipio = tolower(Nome_Municipio)) %>% #Coloca todos os nomes de municipios em minúscula, para facilitar identificação com outras bases 
    mutate(Municipio = gsub(" ", "", Municipio), #Remove espaços no nome dos municípios, para facilitar identificação com outras bases
           Municipio_UF = paste(Municipio, UF, sep = "_")) %>%  #Cria um identificador único de nome do município e UF, para impedir a fusão de municípios homônimos
          mutate(Cod_IBGE_Mun = as.character(Cod_IBGE_Mun)) %>% 
  data.table()

saveRDS(Desastres, file = here("Dados/Desastres.RDS")) #Salva a base de dados tratada na pasta Dados

rm(Desastres) #Limpa a base tratada, para economizar memória enquanto tratamos as demais
```

## 1.3 Dados de produção legislativa

Os dados de produção legislativa foram extraídos a partir das APIs abertas dos sites das câmaras municipais que utilizam o "Sistema de Apoio ao Processo Legislativo".

A lista de municípios participantes pode ser encontrada em: <https://www.senado.leg.br/senado/hotsites/interlegis/orgaos-atendidos.asp>

**O código para raspagem de dados dessa API está na pasta "Scraping", e deve ser rodado antes de utilizar este código.**

```{r, 'Dados_Camaras', warning=FALSE}
#Verifique que o documento com os dados raspados das Câmaras Municipais já está na pasta "Dados"
#ATENÇÃO: Este arquivo é muito pesado. Certifique-se de que seu computador tem memória para tratá-lo

CidadesAL <- read_csv(file= here("Dados/ProjCidades.csv")) %>% 
  data.table()
```

```{r, 'Reduzindo_base'}
library(stringi)

# 1. Remove duplicadas com base em 3 colunas
CidadesAL <- CidadesAL[!duplicated(CidadesAL[, .(data_apresentacao, City, ementa)])]

# 2. Seleciona colunas de interesse
CidadesAL <- CidadesAL[, .(id, data_apresentacao, ano, City, numero, `__str__`, ementa, API_URL)]


# 3. Cria colunas transformadas
CidadesAL[, `:=`(
  Data = as.IDate(data_apresentacao),
  
  Tipo_Projeto = stri_trans_tolower(
    stri_replace_first_regex(`__str__`, " nº.*", "")
  ),
  
  ementa = stri_trans_tolower(
    stri_replace_first_regex(ementa, "\\*.*?\\*", "")
  ),
  
  UF = stri_trans_toupper(
    stri_sub(stri_match_first_regex(API_URL, ".*\\.([^.]+)\\.[^.]+\\..*")[,2], 1, 2)
  )
)]

# 4. Agrupa por City para calcular prim.data e prim.ano
CidadesAL[, `:=`(
  Mês = month(Data),
  prim.ano = min(ano, na.rm = TRUE),
  prim.data = min(Data, na.rm = TRUE)
), by = City]

# 5. Cria coluna Municipio_UF
CidadesAL[, Municipio_UF := stri_trans_general(
  stri_paste(City, UF, sep = "_"),
  "Latin-ASCII")]

# 6. Renomeia colunas
setnames(CidadesAL, old = c("__str__", "City", "ano"), new = c("Nome_Propositura", "Municipio", "Ano"))

```

Agora, irei criar a coluna "Tipo", para garantir que todos os projetos da mesma categoria sejam agrupados juntos:\

```{r, 'mapeando_sinonimos'}
# Mapeando os sinônimos
mapping_dict <- c(
  # Projetos de Lei Ordinária
  "projeto de lei" = "projeto de lei ordinaria",
  "projeto de lei ordinária" = "projeto de lei ordinaria",
  "projeto de lei ordinario" = "projeto de lei ordinaria",
  "projeto de lei ordinário" = "projeto de lei ordinaria",
  "projeto de lei ordinária da câmara" = "projeto de lei ordinaria",
  "projeto de lei (câmara)" = "projeto de lei ordinaria",
  "projeto de lei (legislativo)" = "projeto de lei ordinaria",
  "projeto de lei do legislativo" = "projeto de lei ordinaria",
  "projeto de lei legislativo" = "projeto de lei ordinaria",
  "projeto de lei ordinária do legislativo" = "projeto de lei ordinaria",
  "projeto de lei ordinária legislativo" = "projeto de lei ordinaria",
  "projeto de lei ordinária origem legislativa" = "projeto de lei ordinaria",
  "projeto de lei ordinária (poder legislativo)" = "projeto de lei ordinaria",
  "projeto de lei de vereador" = "projeto de lei ordinaria",
  
  # Projetos de Lei do Executivo
  "projeto de lei - executivo" = "projeto de lei executivo",
  "projeto de lei do executivo" = "projeto de lei executivo",
  "projeto de lei executivo" = "projeto de lei executivo",
  "projeto executivo municipal" = "projeto de lei executivo",
  "projeto de lei ordinária do executivo" = "projeto de lei executivo",
  "projeto de lei ordinária executivo" = "projeto de lei executivo",
  "projeto de lei (executivo)" = "projeto de lei executivo",
  "projeto de lei ordinária (poder executivo)" = "projeto de lei executivo",
  "projeto de lei (prefeitura)" = "projeto de lei executivo",
  
  # Projetos de Lei Complementar
  "projeto de lei complementar" = "projeto de lei complementar",
  "projeto de lei complementar legislativo municipal" = "projeto de lei complementar",
  "projeto de lei complementar do executivo" = "projeto de lei complementar",
  "projeto de lei complementar - executivo" = "projeto de lei complementar",
  "projeto de lei complementar (executivo)" = "projeto de lei complementar",
  "projeto de lei complementar substitutivo" = "projeto de lei complementar",
  
  # Anteprojetos
  "anteprojeto de lei" = "anteprojeto de lei",
  "anteprojeto de lei ordinaria" = "anteprojeto de lei",
  "ante projeto de lei" = "anteprojeto de lei",
  
  # Requerimentos
  "requerimento" = "requerimento",
  "requerimentos" = "requerimento",
  "requerimento legislativo" = "requerimento",
  "requerimento / legislativo" = "requerimento",
  "requerimento de vereador" = "requerimento",
  "requerimento de vereador(a)" = "requerimento",
  "requerimento solicitação" = "requerimento",
  "requerimento especial" = "requerimento",
  "requerimento interno" = "requerimento",
  "requerimento verbal" = "requerimento",
  "requerimento plenário" = "requerimento",
  "requerimento presidência" = "requerimento",
  "requerimento (regimento antigo)" = "requerimento",
  
  # Requerimentos Específicos
  "requerimento de informações" = "requerimento de informacoes",
  "requerimento informações" = "requerimento de informacoes",
  "pedido de informações" = "requerimento de informacoes",
  "pedido de informação" = "requerimento de informacoes",
  
  # Moções
  "moção" = "mocao",
  "moção de aplausos" = "mocao de aplausos",
  "moção aplausos" = "mocao de aplausos",
  "moção de aplauso" = "mocao de aplausos",
  "moção aplauso" = "mocao de aplausos",
  "moção de congratulações" = "mocao de congratulacoes",
  "moção de congratulação" = "mocao de congratulacoes",
  "projeto de moção" = "mocao",
  "moção especial de louvor" = "mocao de louvor",
  "moção de apelo" = "mocao de apelo",
  "moção de reconhecimento" = "mocao de reconhecimento",
  
  # Indicações
  "indicação" = "indicacao",
  "indicações" = "indicacao",
  "indicação - a" = "indicacao",
  "indicação verbal" = "indicacao",
  "indicação ao executivo" = "indicacao",
  "pedido de indicação" = "indicacao",
  "indicação (não usar)" = "indicacao",
  
  # Pareceres
  "parecer" = "parecer",
  "parecer cpjr" = "parecer",
  "parecer cpof" = "parecer",
  "parecer jurídico" = "parecer",
  "parecer conjunto das comissões" = "parecer",
  "parecer das comissões" = "parecer",
  "parecer das comissões permanentes" = "parecer",
  "parecer da comissão" = "parecer",
  "parecer ccj" = "parecer",
  "parecer cfo" = "parecer",
  "parecer cesam" = "parecer",
  "parecer cotsp" = "parecer",
  "parecer contrário ccj" = "parecer",
  "parecer da comissão geral" = "parecer",
  
  # Ofícios
  "oficio" = "oficio",
  "ofício" = "oficio",
  "ofício pmc" = "oficio",
  "ofício expedido" = "oficio",
  "ofício gab ver" = "oficio",
  "ofício legislativo" = "oficio",
  "ofício da administração municipal" = "oficio",
  "ofício do executivo" = "oficio",
  "oficio do executivo" = "oficio",
  "ofício do gabinete do vereador" = "oficio",
  "oficio recebido" = "oficio",
  "ofícios da câmara" = "oficio",
  
  # Emendas
  "emenda" = "emenda",
  "emenda orçamentária" = "emenda orcamentaria",
  "emenda ao projeto de lei" = "emenda projeto lei",
  "emenda à loa" = "emenda loa",
  "emenda à loa (lei orçamentária anual)" = "emenda loa",
  "emenda impositiva" = "emenda impositiva",
  "emenda parlamentar orçamentária impositiva" = "emenda impositiva",
  "emenda impositiva ao orçamento" = "emenda impositiva",
  "emenda parlamentar impositiva à loa" = "emenda impositiva",
  "emenda à ldo (lei de diretrizes orçamentárias)" = "emenda ldo",
  "emenda ao ppa" = "emenda ppa",
  "emenda modificativa" = "emenda modificativa",
  "emenda aditiva" = "emenda aditiva",
  
  # Vetos
  "veto" = "veto",
  "veto do prefeito" = "veto",
  "processo de veto" = "veto",
  "veto parcial a projeto de lei" = "veto",
  "mensagem de veto a projeto de lei" = "veto",
  
  # Pedidos de Providência
  "pedido de providências" = "pedido de providencia",
  "pedido de providência" = "pedido de providencia",
  "pedido de providência " = "pedido de providencia",
  "pedido de providências " = "pedido de providencia",
  
  # Outros
  "decreto" = "decreto",
  "decretos" = "decreto",
  "decreto de calamidade publica" = "decreto calamidade publica",
  "projeto de decreto legislativo" = "projeto decreto legislativo",
  "projeto de resolução" = "projeto resolucao",
  "projeto de resolução legislativa" = "projeto resolucao",
  "substitutivo" = "substitutivo",
  "substitutivo projeto de lei" = "substitutivo",
  "substitutivo ao projeto de lei" = "substitutivo",
  "projeto substitutivo" = "substitutivo",
  "lei ordinaria" = "lei ordinaria",
  "lei ordinária municipal" = "lei ordinaria",
  "lei" = "lei",
  "leis" = "lei",
  "autografo de lei" = "autografo lei",
  "autógrafos" = "autografo lei",
  "medida provisória" = "medida provisoria",
  "protocolo" = "protocolo",
  "protocolo da casa" = "protocolo",
  "processo" = "processo",
  "portaria" = "portaria",
  "portarias" = "portaria",
  "redação final" = "redacao final",
  "projeto de redação final" = "redacao final"
)

# Aplicar mapeamento
CidadesAL[, Tipo := {
  idx <- match(tolower(get("Tipo_Projeto")), names(mapping_dict))
  ifelse(!is.na(idx), mapping_dict[idx], get("Tipo_Projeto"))
}]

rm(mapping_dict)
```

Agora, irei adicionar à base um registro dos termos relacionados às políticas climáticas que serão utilizados na análise, para classificar os projetos a partir de suas ementas.

```{r}

# Lista de termos
termos_clima <- c(" clima", " adaptação climática", " defesa civil", " alagamento",  " inundação", " inundações", " aquecimento global", " mitigação", " chuva", " fortes chuvas", " vento", " deslizamento", " soterramento", " desabamento", " incêndio", " enxurrada", " eventos climáticos extremos"," seca", " estiagem", " estiagens" , " pluvial", " pluviais", " enchente", " chuvoso", " erosão", " descarbonização", " transição energética", " carbono", " efeito estufa")

# 1. Vetorize: cria matriz lógica [linha x termo] de quais termos aparecem
match_matrix <- sapply(termos_clima, function(t) grepl(t, CidadesAL$ementa, ignore.case = TRUE))

# 2. Cria a flag projetoclima
CidadesAL[, projetoclima := rowSums(match_matrix) > 0]

# 3. Cria coluna com termos encontrados (colapsando os que bateram)
CidadesAL[, clima_termos := apply(match_matrix, 1, function(row) {
  paste(termos_clima[row], collapse = ", ")
})]

# 4. Para linhas sem nenhum termo, substitui por NA
CidadesAL[clima_termos == "", clima_termos := NA_character_]

rm(match_matrix, termos_clima)

```

Por fim, vamos salvar a base de Atividade Legislativa das Cidades

```{r, 'salvando_dados_projetos'}

#Base geral
CidadesAL <- CidadesAL %>% 
  select(Data, Ano, Municipio_UF, UF, Tipo, Tipo_Projeto, ementa, clima_termos,  Nome_Propositura, API_URL, prim.data, prim.ano, projetoclima) %>% 
  filter(Municipio_UF != "al_PI") #Removendo Assembleia Legislativa do Piauí

#Salvando na pasta
saveRDS(CidadesAL, file = here("Dados/CidadesAL.RDS"))
```

## 1.4 Definindo o recorte temporal

Uma vez que já limpamos a base de dados de projetos, podemos definir o recorte temporal de análise.

Para utilizar um critério objetivo, será analisada a proporção de municípios presentes no SAPL que estão presentes em cada ano, o volume de produção legislativa em cada período, e a disponibilidade de dados.

```{r, 'Tabela_contagem_AL_tempo'}

# Conferir que os tipos estão corretos.
CidadesAL[, Ano := as.integer(Ano)]
CidadesAL[, Municipio_UF := as.character(Municipio_UF)]

# 1. Get unique year-municipality combinations
municipios_por_ano <- unique(CidadesAL[, .(Ano, Municipio_UF)])

# 2. Create lookup table: for each year, get municipios and join to later years
all_anos <- sort(unique(CidadesAL$Ano))

# 3. Initialize result list
result <- lapply(all_anos, function(ano) {
  # municípios in current year
  munis_i <- municipios_por_ano[Ano == ano, Municipio_UF]

  # filter rows for year i and after, only for those municipalities
  after_rows <- CidadesAL[Ano >= ano & Municipio_UF %in% munis_i]

  data.table(
    Ano = ano,
    n_municipios = length(unique(munis_i)),
    AL_Ano = nrow(CidadesAL[Ano == ano]),
    AL_pos_ano = nrow(after_rows)
  )
})

# Combine all rows into one data.table
df_contagem <- rbindlist(result)

rm(all_anos, municipios_por_ano, result)
```

```{r, 'plotando_contagem_tempo', warning = FALSE}
library(ggplot2)

# Criar o gráfico
sapl_mun_years <- df_contagem %>% 
  filter(Ano >= 1991) %>% 
  ggplot(aes(x = Ano)) +
  # Adicionar o gráfico de barras para "n_municipios"
  geom_bar(aes(y = n_municipios), stat = "identity", fill = "#1B9E77") +
  # Adicionar o gráfico de linha para "AL_pos_ano"
  geom_line(aes(y = AL_pos_ano * (max(df_contagem$n_municipios) / max(df_contagem$AL_pos_ano)))) +
  geom_vline(xintercept = 2013, linetype = "dashed")+
  # Adicionar eixos duplos
  scale_y_continuous(
    name = "Número de Municípios",
    sec.axis = sec_axis(~ . * (max(df_contagem$AL_pos_ano) / max(df_contagem$n_municipios)), name = "Registros nos anos subsequentes (até 2025)",
      breaks = scales::pretty_breaks(),
      labels = scales::comma_format(big.mark = ".", decimal.mark = ","))
  ) +
  scale_x_continuous(n.breaks = 10)+
  # Personalizar cores e temas
  theme_linedraw()+
  labs(title = "Nº de municípios na base de dados por ano x Total de proposituras nos anos subsequentes")+
  theme(title = element_text(size = 9),
        axis.text.y.left = element_text(color = "#1B9E77", size = 10),   # Cor do texto do eixo Y à esquerda
        axis.title.y.left = element_text(color = "#1B9E77"))   # Cor do título do eixo Y à esquerda


sapl_mun_years

ggsave(here("Figuras/1. SAPL recorte temporal.png"), sapl_mun_years)

# Exibir o gráfico
print(sapl_mun_years)

```

```{r}
rm(df_contagem, sapl_mun_years)
```

A partir desta análise, foi escolhido o período de 2013 a 2024 como ponto de corte. Podemos salvar a lista de municípios presentes a partir deste ano com o seguinte código:

```{r}
#Selecionando só os municípios presentes em todo o período selecionado

CidadesAL13_24 <- CidadesAL %>% 
  filter(as.Date("2013-01-01") >= prim.data,
         Data < as.Date("2024-12-31"),
         Data > as.Date("2013-01-01")) %>% 
  data.table()

saveRDS(CidadesAL13_24, here("Dados/CidadesAL13_24.RDS"))

rm(CidadesAL)
```

## 1.5 Projetos climáticos

A seguir, filtraremos apenas os projetos em que foram identificados como tendo termos associados às políticas climáticas.

Primeiro, criamos uma contagem do número total de projetos no dia em cada município, para não perdermos esta informação, além de identificar o dia em relação ao número de dias em que algum projeto foi apresentado

```{r, 'dados_so_clima'}

#Adicionando total de projetos por dia, por tipo de projeto, por cidade

##Criando segunda base de dados sumarizando número de projetos por dia
#Só por projeto e data:
CidadesAL13_24 <- readRDS(here("Dados/CidadesAL13_24.RDS"))

nproj_data <- CidadesAL13_24 %>% 
  group_by(Data, Municipio_UF, Tipo) %>% 
  summarise(total_tipo_proj_dia = n(), .groups = "drop") %>% 
data.table()

# Para evitar contar dias em que # Para evitar contar dias em que # Para evitar contar dias em que as câmaras estão fechadas, criamos a variável "Dia" para levar em conta apenas dias em que elas estão abertas

lista_municipios_datas <- nproj_data[, .(Data = unique(Data)), by = Municipio_UF]

setorder(lista_municipios_datas, Municipio_UF, Data)

lista_municipios_datas[, Dia := seq_len(.N), by = Municipio_UF]

# Step 2: Join lista_municipios_datas back to nproj_data
nproj_data <- merge(nproj_data, lista_municipios_datas, by = c("Municipio_UF", "Data"), all.x = TRUE)

rm(lista_municipios_datas)
```

Agora, vamos filtrar só os projetos em que "projetoclima = T"

```{r}

#Base só com projetos de Clima
CidadesAL13_24 <- CidadesAL13_24 %>% 
  filter(projetoclima == T) %>% 
  select(!c(projetoclima, prim.data, prim.ano)) %>% 
  mutate(Ano = year(as.Date(Data)))



#Juntando as informações
ALClima13_24 <- merge(CidadesAL13_24, nproj_data, by = c("Data", "Municipio_UF", "Tipo"), all.x  = T)

#Salvando (com um NOME DIFERENTE) a base com dados só de clima:
saveRDS(ALClima13_24, file = here("Dados/ALClima13_24.RDS"))

rm(nproj_data, CidadesAL13_24, ALClima13_24) #Removendo baseS temporária
```

## 1.6 Adicionando as variáveis de controle

Agora que já temos uma base de dados com projetos e desastres, podemos começar a adicionar as variáveis de controle

### 1.7.1 Níveis de Risco Climático

Uma importante variável de controle é o de nível de risco climático. Espera-se que a agenda em políticas de adaptação climática seja menor nos municípios que não estão diretamente vulneráveis aos efeitos das mudanças climáticas, e nos que já adotaram medidas de adaptação que dão conta de sua demanda.

O "Sistema Adapta Brasil", produzido pelo Ministério de Ciência e Tecnologia, produz índices dos graus de adaptação dos municípios às mudanças climáticas a partir de uma série de indicadores : [https://sistema.adaptabrasil.mcti.gov.br/https://sistema.adaptabrasil.mcti.gov.br/](https://sistema.adaptabrasil.mcti.gov.br/){.uri}

Iremos importar essa base para todos os municípios, incluindo dados segmentados sobre Vulnerabilidades, Nível de Ameaça Climática, Sensibilidade e Nível de Adaptação.

```{r}
#Importando os pacotes necessários:
library(httr)
library(jsonlite)
library(stringr)
library(purrr)
```

Primeiro, certifique-se de baixar e deixar o arquivo "adaptaBrasilAPIEstrutura.csv" dentro da pasta "Dados". Ela pode ser produzida ou baixada no Github oficial do projeto AdaptaBrasil: <https://github.com/AdaptaBrasil/AdaptaBrasilAPIAccess?tab=readme-ov-file>

```{r}
#Subindo e limpando a base de links (disponível em: https://github.com/AdaptaBrasil/AdaptaBrasilAPIAccess?tab=readme-ov-file )
AdaptaBrasil <- read.csv(here("Dados/adaptaBrasilAPIEstrutura.csv"), sep = "|") %>%
  filter(nivel %in% c(2:4),
        setor_estrategico %in% c("Recursos Hídricos", "Segurança Alimentar", "Desastres Hidrológicos"))


```

```{r}
# Lista para armazenar os data.frames resultantes
AdaptaBrasilInd <- list()

# Função auxiliar para gerar nome único para cada dataframe
gerar_nome_df <- function(setor, nivel, nome) {
  nome_limpo <- str_replace_all(paste(nivel, setor, nome, sep = "_"), "\\s+", "_")
  nome_limpo <- str_replace_all(nome_limpo, "[^[:alnum:]_]", "") # remove caracteres especiais
  return(nome_limpo)
}

# Loop por cada linha do dataframe filtrado
for (i in seq_len(nrow(AdaptaBrasil))) {
  
  # Extrai a URL e campos de nomeação
  url <- AdaptaBrasil$url_obtem_dados_indicador[i]
  setor <- AdaptaBrasil$setor_estrategico[i]
  nivel <- AdaptaBrasil$nivel[i]
  nome <- AdaptaBrasil$nome[i]
  
  # Gera nome da lista/dataframe
  nome_df <- gerar_nome_df(setor, nivel, nome)
  
  # Tenta fazer a requisição GET e tratar a resposta
  try({
    resposta <- GET(url)
    if (status_code(resposta) == 200) {
      conteudo_json <- content(resposta, "text", encoding = "UTF-8")
      dados <- fromJSON(conteudo_json, flatten = TRUE)
      
      # Converte para dataframe (caso necessário)
      if (is.data.frame(dados)) {
        AdaptaBrasilInd[[nome_df]] <- dados
      } else if (is.list(dados)) {
        AdaptaBrasilInd[[nome_df]] <- as.data.frame(dados)
      }
    } else {
      message(sprintf("Falha na URL %s - Código: %d", url, status_code(resposta)))
    }
  }, silent = TRUE)
}

rm(conteudo_json, dados, gerar_nome_df, i, nivel, nome, nome_df, resposta, setor, url)
```

```{r}
library(tidyr)
# Adiciona uma coluna "indicador_origem" com o nome da lista para identificar a origem de cada dataframe
AdaptaBrasil <- imap(AdaptaBrasilInd, ~ mutate(.x, indicador_origem = .y))

# Junta todos os dataframes em um único dataframe
AdaptaBrasil <- bind_rows(AdaptaBrasil) %>% 
  rename(Cod_IBGE_Mun = geocod_ibge) %>% 
  mutate(Municipio_UF = str_replace(name, "/", "_"),
         label = paste0("label_", indicador_origem)) %>% 
  select(Cod_IBGE_Mun, Municipio_UF, value, indicador_origem) %>%  
  pivot_wider(names_from = indicador_origem, values_from = value, names_prefix = "AB") %>% 
  mutate(
    Municipio_UF = paste0(
      tolower(substr(Municipio_UF, 1, nchar(Municipio_UF) - 2)),
      toupper(substr(Municipio_UF, nchar(Municipio_UF) - 1, nchar(Municipio_UF)))
    ),
    Municipio_UF = str_replace_all(Municipio_UF, "[-' ]", ""),
    Municipio_UF = stri_trans_general(Municipio_UF, "Latin-ASCII")) %>% 
  data.table()

saveRDS(AdaptaBrasil, here("Dados/AdaptaBrasil.RDS"))

rm(AdaptaBrasilInd, AdaptaBrasil)
```

### 1.7.2 Grupos de Interesse (OSCs, Associações, ONGs, etc)

Um dos elementos presentes em toda a literatura a respeito da produção de política climáticas é o papel de organizações da sociedade civil em pressionar os agentes públicos, ajudando a colocar a pauta climática na agenda.

No Brasil, essas organizações inscrevem seus CNPJs como "Organizações da Sociedade Civil" (OSCs). O IPEA disponibiliza o levantamento de todas essas organizações na plataforma "Mapa das OSCs". Iremos levantar e tratar esses dados para utilizar na análise:

Fonte dos dados: <https://mapaosc.ipea.gov.br/base-dados>

Certifique-se que estão na pasta "Dados" os arquivos:

-   base_OSC_agosto_2023.csv

-   area_subarea.xlsx

```{r}
#Baixando a base
OSCs <- read_csv2(here("Dados/base_OSC_agosto_2023.csv"))

#Selecionando só as colunas de interesse

OSCs <- OSCs %>% 
  select(!c(tx_nome_fantasia_osc, cd_natureza_juridica_osc, tx_endereco_completo, cd_uf, tx_latitude, tx_longitude, cnae, cnae_fiscal_secundaria)) %>% 
  pivot_longer(cols = starts_with("Area_"), names_prefix = "Area_", names_to = "Area", values_to = "Value") %>% 
  filter(Value == 1) %>% 
  pivot_longer(cols = starts_with("SubArea_"), names_prefix = "SubArea_", names_to = "Subarea", values_to = "ValueSub") %>% 
  filter(ValueSub == 1) %>% 
  rename("Cod_IBGE_Mun" = cd_municipio) %>% 
    select(!c(Value, ValueSub))
```

```{r}

#Adicionando áreas
library(readxl) #pacote necessário

#Adiciona a tabela com subáreas:
OSC_Area <- read_xlsx(here("Dados/area_subarea.xlsx"))

#Seleciona as colunas de interesse:
OSC_Area <- OSC_Area %>% 
  select(!c(id_osc...1, tx_razao_social_osc, tx_nome_fantasia_osc, dt_fundacao_osc, cd_natureza_juridica_osc, edmu_cd_municipio, edmu_nm_municipio, eduf_cd_uf, eduf_sg_uf, id_osc...12, id_osc...24, `HabitaÃ§Ã£o`, `SaÃºde`,	`Cultura e recreaÃ§Ã£o`, `EducaÃ§Ã£o e pesquisa`,	`AssistÃªncia social`,	`ReligiÃ£o`, 	`AssociaÃ§Ãµes patronais, profissionais e de produtores rurais`, 	`Meio ambiente e proteÃ§Ã£o animal`, 	`Desenvolvimento e defesa de direitos`,	`Outros`,	`Outras atividades associativas`)) %>% 
  rename(cnpj = cd_identificador_osc) %>% 
  pivot_longer(cols = c(3:46), names_to = "Subarea2", values_to = "Value") %>% 
  filter(Value == 1) %>% 
  select(!Value) %>%
  mutate(across(where(is.character), ~ iconv(., from = "UTF-8", to = "latin1")))
```

```{r}
#Juntando as duas

OSCs <- merge(OSCs, OSC_Area, by = c("cnpj"), all.x = T) %>% 
  mutate(Subarea2 = ifelse(is.na(Subarea2), Subarea, Subarea2))

rm(OSC_Area)



```

```{r}
#Limpando termos de OSCs que dizem pouco a respeito da agenda climática:

OSCs <- OSCs %>% 
  filter(!Area %in%  c("Religiao", "Cultura_e_recreacao"), 
         !Subarea %in% c("Educacao_infantil", "Ensino_fundamental", "Ensino_superior", "Hospitais", "Religiao", "Educacao_profissional", "Cultura_e_arte", "Esportes_e_recreacao"),
         !Subarea2 %in% c("Cultura sub Cultura e arte", "Religiao sub Outros", "	
Desenv e Def sub Religião", "Educacao sub Educação superior", "	
Saude sub Hospitais", "Educacao sub Ensino médio", "Cultura sub Outros"), 
         !tx_nome_classe_atividade_economica %in% c("tx_nome_classe_atividade_economica", "Atividades de assistência psicossocial e à saúde a portadores de distúrbios psíquicos, deficiência mental e dependência química", "Ensino de esportes", "Atividades de atenção ambulatorial executadas por médicos e odontólogos", "Ensino de arte e cultura", "Atividades de serviços de complementação diagnóstica e terapêutica", "Atividades de organizações religiosas", "Ensino de idiomas", "Artes cênicas, espetáculos e atividades complementares", "Ensino fundamental", "Educação infantil - creche", "Atividades de rádio", "Educação superior - graduação e pós-graduação", "Clubes sociais, esportivos e similares", "Educação superior - graduação", "Atividades de atendimento hospitalar", "	
Educação infantil - pré-escola", "	
Educação profissional de nível técnico", "	
Planos de saúde", "	
Atividades de museus e de exploração, restauração artística e conservação de lugares e prédios históricos e atrações similares", "	
Comércio varejista de livros, jornais, revistas e papelaria", "Criação artística", "Serviços de remoção de pacientes, exceto os serviços móveis de atendimento a urgências", "Atividades de televisão aberta", "Comércio atacadista de resíduos e sucatas", "Atividades de produção cinematográfica, de vídeos e de programas de televisão", "Atividades de bibliotecas e arquivos", "Comércio atacadista de produtos alimentícios em geral", "Comércio varejista de outros produtos novos não especificados anteriormente", "Educação profissional de nível tecnológico", "Atividades de exibição cinematográfica", "Ensino médio", "Atividades de contabilidade, consultoria e auditoria contábil e tributária", "Edição de livros", "Fotocópias, preparação de documentos e outros serviços especializados de apoio administrativo", "Programadoras e atividades relacionadas à televisão por assinatura", "Restaurantes e outros estabelecimentos de serviços de alimentação e bebidas", "Comércio atacadista de cereais e leguminosas beneficiados, farinhas, amidos e féculas", "Comércio varejista de produtos farmacêuticos para uso humano e veterinário", "Transporte rodoviário coletivo de passageiros, com itinerário fixo, municipal e em região metropolitana", "Transporte rodoviário coletivo de passageiros, sob regime de fretamento, e outros transportes rodoviários não especificados anteriormente", "Atividades de gravação de som e de edição de música", "Comércio varejista de artigos médicos e ortopédicos", "Comércio varejista de artigos recreativos e esportivos", "Comércio varejista de produtos alimentícios em geral ou especializado em produtos alimentícios não especificados anteriormente; produtos do fumo", "Comércio varejista de produtos de padaria, laticínio, doces, balas e semelhantes", "Desenvolvimento de programas de computador sob encomenda", "Edição integrada à impressão de livros", "Estacionamento de veículos", "Hotéis e similares", "Portais, provedores de conteúdo e outros serviços de informação na internet", "Transporte escolar", "Atividades de exploração de jogos de azar e apostas", "Educação infantil - pré-escola", "Transporte rodoviário de táxi", "Edição integrada à impressão de revistas", "Serviços de pré-impressão"))

```

```{r}

#Sumarizando:
OSCsClima <- OSCs %>% 
  group_by(Cod_IBGE_Mun, dt_fundacao_osc) %>% 
  summarise(n = n()) %>% 
  pivot_wider(names_from = "Cod_IBGE_Mun", values_from = n) %>%
  arrange(dt_fundacao_osc) %>% 
  as.data.table()

# Removendo NAs:
cols <- setdiff(names(OSCsClima), "dt_fundacao_osc")
OSCsClima[, (cols) := lapply(.SD, function(x) fifelse(is.na(x), 0L, x)), .SDcols = cols]

# Calculando cumulativo de OSCs por cidade
OSCsClima[, (cols) := lapply(.SD, cumsum), .SDcols = cols]

# Pivot Longer para Coluna "Cod_IBGE_Mun"
OSCsClima <- OSCsClima %>% 
  melt(id.vars = "dt_fundacao_osc", # Mantém data inalterada
  variable.name = "Cod_IBGE_Mun",   # Transfere as demais colunas para "Cod_IBGE_Mun"
  value.name = "n_OSCs"         # Transfere os valores para n_OSCs
)

#Separando só datas a partir de 2013
OSCsClima <- OSCsClima[dt_fundacao_osc >= as.Date("2013-01-01"), ] %>% 
  rename("Data" = dt_fundacao_osc) %>% 
  data.table()

saveRDS(OSCsClima, here("Dados/OSCsClima.RDS"))

rm(OSCs, OSCsClima, lista_municipios, cols)
```

### 1.7.3 Orçamento Municipal

Outra variável importante levantada na bibliografia é a disponibilidade de recursos. Usamos as receitas orçamentárias municipais como proxy para essa variável.

As receitas orçamentárias anuais estão disponíveis no site do "Sistema de Informações Contabéis e Fiscais do Setor Público Brasileiro - SICONFI", a partir da prestação de contas anuais: <https://siconfi.tesouro.gov.br/siconfi/pages/public/consulta_finbra/finbra_list.jsf>

Para facilitar a leitura, o Senado Federal, através do "Panorama do Legislativo Municipal", compila os dados dos orçamentos municipais já tratados **entre 2013 e 2021**

Dados: <https://www.senado.leg.br/institucional/datasenado/panorama/#/dados>

```{r}
orcamento <- read.csv2(here("Dados/orcamentodomunicipio.csv"), encoding = "UTF-8")

#Permite visualizar corretamento os caracteres:
orcamento[] <- lapply(orcamento, function(x) {
  if (is.character(x)) iconv(x, from = "Latin1", to = "UTF-8") else x
})

#Dados do orçamento municipal
orcamento <- orcamento %>% 
  select(!Porcentagem) %>% 
  filter(Categoria == "Receitas realizadas") %>% 
  pivot_wider(names_from = Categoria,
              values_from = Valor, 
              names_prefix = "Orcamento_Mun ") %>% 
  rename("Cod_IBGE_Mun" = "Cod.IBGE", 
         "Receitas_Mun" = "Orcamento_Mun Receitas realizadas")
```

E agora, adicionando os dados de 2022 a 2024:

```{r}
#Orçamento 2022
orcamento2022 <- read.csv2(here("Dados/finbra2022.csv"), skip = 3, sep = ";", encoding = "latin1")

orcamento2022 <- orcamento2022 %>% 
  filter(Conta == "RECEITAS (EXCETO INTRA-ORÇAMENTÁRIAS) (I)", 
         Coluna == "Receitas Brutas Realizadas") %>% 
  rename(Cod_IBGE_Mun = Cod.IBGE, 
         "Receitas_Mun" = Valor) %>% 
  mutate(Ano = 2022) %>% 
  select(Cod_IBGE_Mun, Ano, Receitas_Mun)

#Orçamento 2023

orcamento2023 <- read.csv2(here("Dados/finbra2023.csv"), skip = 3, sep = ";", encoding = "latin1")

orcamento2023 <- orcamento2023 %>% 
  filter(Conta == "RECEITAS (EXCETO INTRA-ORÇAMENTÁRIAS) (I)", 
         Coluna == "Receitas Brutas Realizadas") %>% 
  rename(Cod_IBGE_Mun = Cod.IBGE, 
         "Receitas_Mun" = Valor) %>% 
  mutate(Ano = 2023) %>% 
  select(Cod_IBGE_Mun, Ano, Receitas_Mun)

#Orçamento 2024
orcamento2024 <- read.csv2(here("Dados/finbra2024.csv"), skip = 3, sep = ";", encoding = "latin1")

orcamento2024 <- orcamento2024 %>% 
  filter(Conta == "RECEITAS (EXCETO INTRA-ORÇAMENTÁRIAS) (I)", 
         Coluna == "Receitas Brutas Realizadas") %>% 
  rename(Cod_IBGE_Mun = Cod.IBGE, 
         "Receitas_Mun" = Valor) %>% 
  mutate(Ano = 2024) %>% 
  select(Cod_IBGE_Mun, Ano, Receitas_Mun)

#Juntando as bases

orcamento <- bind_rows(orcamento, orcamento2022)

orcamento <- bind_rows(orcamento, orcamento2023)

orcamento <- bind_rows(orcamento, orcamento2024)

saveRDS(orcamento, here("Dados/orcamento2013_2024.RDS"))

rm(orcamento, orcamento2022, orcamento2023, orcamento2024)
```

### 1.7.4 - Datas eleições TSE

Outra variável relevante é a proximidade de eleições. Elas afetam o comportamento dos políticos e podem alterar o comportamento legislativo. Vamos criar uma base com as datas dos 1ºturnos das eleições municipais no período analisado, extraída do calendário do TSE: [https://www.tse.jus.br/eleicoes/eleicoes-anteriores?tab=ancora-3](#0){.uri}

<https://www.tse.jus.br/eleicoes/calendario-eleitoral/calendario-eleitoral>

```{r}
eleicoes <- data.frame("eleicoes" = c("1992-10-03", "1996-10-03", "2000-10-01", "2004-10-03", "2008-10-05", "2012-10-07", "2016-10-02", "2020-11-15", "2024-10-06", "2028-10-08"))

saveRDS(eleicoes, here("Dados/eleicoes.RDS"))

rm(eleicoes)
```

### 1.7.5 - População

Por fim, podemos adicionar a população dos municípios. As estimativas de população pelo IBGE podem ser encontradas em : <https://sidra.ibge.gov.br/Tabela/6579> e [https://sidra.ibge.gov.br/Tabela/](https://sidra.ibge.gov.br/Tabela/200){.uri}[4709](https://sidra.ibge.gov.br/tabela/4709) (para o Censo de 2022)

Para o ano de 2023, foi utilizada a "Relação da População dos Municípios enviada ao TCU:" [https://www.ibge.gov.br/estatisticas/sociais/populacao/37734-relacao-da-populacao-dos-municipios-para-publicacao-no-tcu.htmlhttps://www.ibge.gov.br/estatisticas/sociais/populacao/37734-relacao-da-populacao-dos-municipios-para-publicacao-no-tcu.html](https://www.ibge.gov.br/estatisticas/sociais/populacao/37734-relacao-da-populacao-dos-municipios-para-publicacao-no-tcu.html){.uri}

```{r}

Pop2022 <- read_xlsx(here("Dados/tabela4709.xlsx"), skip = 3) %>% 
  rename("Cod_IBGE_Mun" = 2,
         "Nome_Municipio" = 3) %>% 
  pivot_longer(cols = starts_with("20"), names_to = "Ano", values_to = "Populacao") %>% 
  select(!1)


Pop2023 <- read_excel((here("Dados/POP_TCU_2023_Municipios_POP2022_Malha2023.xls")), skip = 1) %>% 
  mutate(Cod_IBGE_Mun = paste0(`COD. UF`, `COD. MUNIC`),
         Ano = as.character(2023)) %>% 
  rename("Nome_Municipio" = `NOME DO MUNICÍPIO`, 
         "Populacao" = `POPULAÇÃO APURADA IBGE 
- CENSO DEMOGRÁFICO 2022 E MALHA TERRITORIAL 2023 -`) %>% 
  select(Cod_IBGE_Mun, Nome_Municipio, Ano, Populacao) %>% 
  filter(!is.na(Populacao))

Populacao <- read_xlsx(here("Dados/tabela6579.xlsx"), skip = 3)%>% 
  rename("Cod_IBGE_Mun" = 2,
         "Nome_Municipio" = 3) %>% 
  pivot_longer(cols = starts_with("20"), names_to = "Ano", values_to = "Populacao") %>% 
  select(!1) %>% 
  bind_rows(Pop2022)%>% 
  mutate(Populacao = as.character(Populacao)) %>% 
  bind_rows(Pop2023)

saveRDS(Populacao, here("Dados/Populacao.RDS"))

rm(Pop2022, Pop2023, Populacao)
```

## 1.8 Juntando as bases de dados

Agora, vamos juntar todas as bases de dados. Vamos criar duas bases: ALClima (que será utilizada para análise substantiva dos dados) e df_OLS (que será utilizada para a análise quantitativa)

### + Cria df_ols

```{r}
#Recuperando as duas bases
ALClima13_24 <- readRDS(here("Dados/ALClima13_24.RDS"))

CidadesAL <- readRDS(here("Dados/CidadesAL13_24.RDS"))

#Selecionando só municípios da seleção:
CidadesAL <- CidadesAL[Municipio_UF %in% ALClima13_24$Municipio_UF]

#Criando base com total de projetos por dia

df_ols <- ALClima13_24[, .(n_proj_clima = .N), by = .(Data, Municipio_UF)]
  
total_prop <- CidadesAL[, .(total_proj_dia = .N), by = .(Data, Municipio_UF)]

df_ols <- merge(df_ols, total_prop, by = c("Data", "Municipio_UF"), all = T) 


# Adicionando razão entre projetos climáticos e total de projetos

df_ols[, `:=`(
  agenda_clima = n_proj_clima / total_proj_dia,
  Data = as.Date(Data)
)]

rm(CidadesAL, total_prop)
```

### + AdaptaBrasil

Em seguida, adicionamos as informações do AdaptaBrasil à nossa base de ALClima para os anos analisados

```{r}

AdaptaBrasil <- readRDS(here("Dados/AdaptaBrasil.RDS"))

#Juntando as bases:
df <- merge(ALClima13_24, AdaptaBrasil, by = c("Municipio_UF"), all.x = T)

df_ols <- merge(df_ols, AdaptaBrasil, by = c("Municipio_UF"), all.x = T)

rm(ALClima13_24, AdaptaBrasil)
```

### + Desastres

Agora, vamos adicionar as informações sobre os desastres

Para isso, adicionamos a informação sobre a distância entre a data do desastres mais recente (ou do desastre seguinte) em relação à apresentação do projeto. Esta informação irá ajudar a compreender melhor o contexto em que um projeto foi apresentado

```{r}

Desastres <- readRDS(here("Dados/Desastres.RDS"))

#Selectionando os desastres anteriores:

## Juntando as duas bases:
df_prev <- merge(df, Desastres, by = "Cod_IBGE_Mun", allow.cartesian = TRUE, suffixes = c("", "_desastre"))

# Filtra desastes com data menor que a atual
df_prev <- df_prev[Data_desastre < Data]
# Mantém o desastre mais recente (UF, Municipio_UF, Cod_IBGE_Mun, Nome_Municipio, Data):
df_prev <- df_prev[, .SD[which.max(Data_desastre)], by = .(UF, Municipio_UF, Cod_IBGE_Mun, Nome_Municipio, Data)]
# Select and rename columns
df_prev <- df_prev[, .(UF, Municipio_UF, Cod_IBGE_Mun, Nome_Municipio, Data,
                       data_desastre_anterior = Data_desastre,
                       desastre_anterior = Desastre,
                       obitos_desastre_anterior = DH_MORTOS)]

# Repete para próximo desastre
df_next <- merge(df, Desastres, by = "Cod_IBGE_Mun", allow.cartesian = TRUE, suffixes = c("", "_desastre"))

df_next <- df_next[Data_desastre >= Data]

df_next <- df_next[, .SD[which.min(Data_desastre)], by = .(UF, Municipio_UF, Cod_IBGE_Mun, Nome_Municipio, Data)]

df_next <- df_next[, .(UF, Municipio_UF, Cod_IBGE_Mun, Data,
                       data_desastre_proximo = Data_desastre,
                       desastre_proximo = Desastre,
                       obitos_desastre_proximo = DH_MORTOS)]

# Junta as duas à base original
setkeyv(df, c("UF", "Municipio_UF", "Cod_IBGE_Mun", "Data"))
setkeyv(df_prev, c("UF", "Municipio_UF", "Cod_IBGE_Mun", "Data"))
setkeyv(df_next, c("UF", "Municipio_UF", "Cod_IBGE_Mun", "Data"))

df <- df %>% 
  merge(df_prev, by = c("UF", "Municipio_UF", "Cod_IBGE_Mun", "Data"), all.x = TRUE) %>% 
  merge(df_next, by = c("UF", "Municipio_UF", "Cod_IBGE_Mun", "Data"), all.x = TRUE)

# Adiciona colunas com dias até o próximo desastre:
df[, `:=`(
  dias_desastre_anterior = as.integer(as.Date(Data) - as.Date(data_desastre_anterior)),
  dias_desastre_proximo = as.integer(as.Date(Data) - as.Date(data_desastre_proximo)))]

rm(df_next, df_prev)
```

```{r}
#Agora com o df_ols

#Separando datas desastres
dados_desastres <- unique(
  Desastres[, .(Cod_IBGE_Mun, Data = as.Date(Data), 
             Tipo_Desastre = Desastre, 
             Obitos = DH_MORTOS)]
)[, Desastre := 1L]
#Limpando só os municípios e datas selecionadas:
dados_desastres <- dados_desastres[Cod_IBGE_Mun %in% df_ols$Cod_IBGE_Mun & Data >= as.Date("2013-01-01")]

dados_munic <- df_ols %>% 
  group_by(Cod_IBGE_Mun, Municipio_UF, across(AB2_Recursos_Hídricos_Seca: AB4_Desastres_Hidrológicos_Sensibilidade)) %>% 
  summarise() %>% 
  filter(!is.na(AB2_Recursos_Hídricos_Seca))

dados_desastres <- merge(dados_desastres, dados_munic, by = c("Cod_IBGE_Mun"), all.x = T)
  
cols = dados_desastres %>% 
  select(!c(Tipo_Desastre, Obitos, Desastre)) %>% 
  names()

#Juntando as bases:
df_ols <- merge(df_ols, dados_desastres, by = c(cols), all = T) 




# Adiciona colunas com dias desde último desastre:

df_prev <- merge(df_ols, Desastres, by = "Cod_IBGE_Mun", allow.cartesian = TRUE, suffixes = c("", "_desastre"))

# Filtra desastes com data menor que a atual
df_prev <- df_prev[Data_desastre < Data]
# Mantém o desastre mais recente (Municipio_UF, Cod_IBGE_Mun, Nome_Municipio, Data):
df_prev <- df_prev[, .SD[which.max(Data_desastre)], by = .(Cod_IBGE_Mun, Data)]

# Select and rename columns
df_prev <- df_prev[, .(Cod_IBGE_Mun, Data,
                       data_desastre_anterior = Data_desastre,
                       desastre_anterior = Desastre,
                       obitos_desastre_anterior = DH_MORTOS)]

setkeyv(df_ols, c("Cod_IBGE_Mun", "Data"))
setkeyv(df_prev, c("Cod_IBGE_Mun", "Data"))

df_ols <- merge(df_ols, df_prev, by = c("Cod_IBGE_Mun", "Data"), all.x = TRUE)

# Adiciona colunas com dias até o próximo desastre:
df_ols[, dias_desastre_anterior := (as.integer(as.Date(Data) - as.Date(data_desastre_anterior)))]

# Remove os objetos que não serão mais utilizados
rm(Desastres, dados_desastres, dados_munic, cols, df_prev)
```

### +Orçamento Municipal

```{r}
orcamento <- readRDS(here("Dados/orcamento2013_2024.RDS")) %>% 
  mutate(Cod_IBGE_Mun = as.character(Cod_IBGE_Mun)) 

df <- merge(df, orcamento, by = c("Cod_IBGE_Mun", "Ano"), all.x = T)

df_ols[,Ano := year(Data)]

df_ols <- merge(df_ols, orcamento, by = c("Cod_IBGE_Mun", "Ano"), all.x = T)

rm(orcamento)
```

### + Data das Eleições

```{r}

eleicoes <- readRDS(here("Dados/eleicoes.RDS")) %>% 
  data.table()

# Criando base de dados alinhando combinações de projetos e deastres que aconteceram antes deles
eleicoes_grid <- expand_grid(
  Data = seq(as.Date("2013-01-01"), as.Date("2024-12-31"), by = "day"),
  proxima_eleicao = eleicoes$eleicoes) %>%
  filter(proxima_eleicao >= Data) %>%
  group_by(Data) %>%
  slice_min(proxima_eleicao, with_ties = FALSE) %>%
  ungroup() %>% 
  mutate(dias_proxima_eleicao = as.Date(proxima_eleicao) - as.Date(Data),
         dias_proxima_eleicao = as.integer(dias_proxima_eleicao)) %>% 
  data.table()

df <- merge(df, eleicoes_grid, by = "Data", all.x = T)

#ols

eleicoes <- eleicoes %>% 
  rename(Data = eleicoes) %>% 
  mutate(Data = as.Date(Data),
         eleicao = 1)

df_ols <- df_ols %>% 
  merge(eleicoes, by = "Data", all.x = T) %>% 
  merge(eleicoes_grid, by = "Data", all.x = T)


# Remove os objetos que não serão mais utilizados
rm(eleicoes, eleicoes_grid)
```

### +OSCs

```{r}
OSCsClima <- readRDS(here("Dados/OSCsClima.RDS"))

df <- merge(df, OSCsClima, by = c("Cod_IBGE_Mun", "Data"), all.x = T)

df_ols <- merge(df_ols, OSCsClima, by = c("Cod_IBGE_Mun", "Data"), all.x = T)

rm(OSCsClima)
```

### +População

```{r}
Populacao <- readRDS(here("Dados/Populacao.RDS")) %>% 
  select(Cod_IBGE_Mun, Ano, Populacao) %>% 
  mutate(Cod_IBGE_Mun = as.character(Cod_IBGE_Mun),
         Ano = as.integer(Ano), 
         Populacao = as.integer(Populacao)) %>% 
  filter(!is.na(Populacao))

df <- merge(df, Populacao, by = c("Cod_IBGE_Mun", "Ano"), all.x = T)

df_ols <- merge(df_ols, Populacao, by = c("Cod_IBGE_Mun", "Ano"), all.x = T)

rm(Populacao)
```

### Últimas adições:

```{r}
#Adicionando 0 onde faltam: 
df_ols[, (c( "n_proj_clima", "total_proj_dia", "agenda_clima", "Obitos", "Desastre", "eleicao")) := lapply(.SD, function(x) fifelse(is.na(x), 0, x)), .SDcols = c("n_proj_clima", "total_proj_dia", "agenda_clima", "Obitos", "Desastre", "eleicao")]


#Adicionando coluna com mês
df[, `:=`(Mes = lubridate::month(as.Date(Data)))]

df_ols[, Mes := month(Data)]

#Adicionando dia em relação ao período total
Dias <- unique(df_ols[, .(Data)]) %>% 
  arrange(Data)
Dias[, Dia := seq_len(.N)]

df_ols <- merge(df_ols, Dias, by = "Data", all.x = T)

rm(Dias)

#Removendo duplicatas de df_ols

df_ols<- df_ols[
  order(Cod_IBGE_Mun, Dia, -Obitos),  # Ordena por Cod_IBGE_Mun, Dia, e Obitos
  .SD[1],                             # Pega a coluna com maior número de óbitos
  by = .(Cod_IBGE_Mun, Dia)           # Agrupa por Cod_IBGE_Mun and Dia
]

```

```{r}
#Preenchendo valores de NA restantes:
# -- Forward fill de n_OSCs nos faltantes
df_ols[, n_OSCs := nafill(n_OSCs, type = "locf"), by = Cod_IBGE_Mun]

df_ols[, "n_OSCs" := lapply(.SD, function(x) fifelse(is.na(x), 0, x)), .SDcols = "n_OSCs"]

# Preenchendo os "Receita_Mun" faltantes
lookup_receitas <- df_ols[!is.na(Receitas_Mun), .(Cod_IBGE_Mun, Ano, Receitas_Mun)]
setkeyv(df_ols, c("Cod_IBGE_Mun", "Ano"))
setkeyv(lookup_receitas, c("Cod_IBGE_Mun", "Ano"))

df_ols[lookup_receitas, on = c("Cod_IBGE_Mun", "Ano"), Receitas_Mun := i.Receitas_Mun]


rm(lookup_receitas)

```

### Salvando base de dados final

```{r}
#df:
df<- df %>% 
  mutate(Nome_Municipio = ifelse(is.na(Nome_Municipio), Municipio_UF, Nome_Municipio)) %>% 
  select(Data, Ano, Mes, Dia, 
         Cod_IBGE_Mun, Nome_Municipio, UF, 
         Nome_Propositura, Tipo,  Tipo_Projeto, ementa, API_URL, total_tipo_proj_dia, 
         clima_termos,
         data_desastre_anterior, desastre_anterior, obitos_desastre_anterior, dias_desastre_anterior,
         data_desastre_proximo, desastre_proximo, obitos_desastre_proximo, dias_desastre_proximo, 
         Receitas_Mun, Populacao, proxima_eleicao, dias_proxima_eleicao, n_OSCs, 
         AB2_Recursos_Hídricos_Seca, 
           AB3_Recursos_Hídricos_Ameaça_Climática,
           AB3_Recursos_Hídricos_Exposição,
           AB3_Recursos_Hídricos_Vulnerabilidade, 
            AB4_Recursos_Hídricos_Sensibilidade,
            AB4_Recursos_Hídricos_Capacidade_Adaptativa,
         AB2_Segurança_Alimentar_Seca, 
         AB2_Segurança_Alimentar_Chuva,
           AB3_Segurança_Alimentar_Ameaça_Climática,
           AB3_Segurança_Alimentar_Exposição,
           AB3_Segurança_Alimentar_Vulnerabilidade,
            AB4_Segurança_Alimentar_Sensibilidade,
            AB4_Segurança_Alimentar_Capacidade_Adaptativa,
         AB2_Desastres_Hidrológicos_Inundações_enxurradas_e_alagamentos,
         AB2_Desastres_Hidrológicos_Deslizamento_de_terra,
          AB3_Desastres_Hidrológicos_Ameaça, 
          AB3_Desastres_Hidrológicos_Exposição,
          AB3_Desastres_Hidrológicos_Vulnerabilidade, 
           AB4_Desastres_Hidrológicos_Sensibilidade,
           AB4_Desastres_Hidrológicos_Capacidade_Adaptativa)

saveRDS(df, here("Dados/df_agendaclima_municipal.RDS"))


rm(df)
```

```{r}
#Salvando df_ols

df_ols <- df_ols %>% 
  select(Data, Ano, Mes, Dia, Cod_IBGE_Mun, Municipio_UF,
         n_proj_clima, total_proj_dia, agenda_clima, 
         Desastre, Tipo_Desastre, Obitos, eleicao, Receitas_Mun, n_OSCs, Populacao, 
         data_desastre_anterior, desastre_anterior, obitos_desastre_anterior, dias_desastre_anterior,proxima_eleicao, dias_proxima_eleicao, 
         AB2_Recursos_Hídricos_Seca, 
           AB3_Recursos_Hídricos_Ameaça_Climática,
           AB3_Recursos_Hídricos_Exposição,
           AB3_Recursos_Hídricos_Vulnerabilidade, 
            AB4_Recursos_Hídricos_Sensibilidade,
            AB4_Recursos_Hídricos_Capacidade_Adaptativa,
         AB2_Segurança_Alimentar_Seca, 
         AB2_Segurança_Alimentar_Chuva,
           AB3_Segurança_Alimentar_Ameaça_Climática,
           AB3_Segurança_Alimentar_Exposição,
           AB3_Segurança_Alimentar_Vulnerabilidade,
            AB4_Segurança_Alimentar_Sensibilidade,
            AB4_Segurança_Alimentar_Capacidade_Adaptativa,
         AB2_Desastres_Hidrológicos_Inundações_enxurradas_e_alagamentos,
         AB2_Desastres_Hidrológicos_Deslizamento_de_terra,
          AB3_Desastres_Hidrológicos_Ameaça, 
          AB3_Desastres_Hidrológicos_Exposição,
          AB3_Desastres_Hidrológicos_Vulnerabilidade, 
           AB4_Desastres_Hidrológicos_Sensibilidade,
           AB4_Desastres_Hidrológicos_Capacidade_Adaptativa)

saveRDS(df_ols, here("Dados/df_ols.RDS"))


rm(df_ols)
```

**PROSSIGA PARA ARQUIVO "2. Análise descritiva do banco de dados"**
